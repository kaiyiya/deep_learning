---
title: 具体数学-作业1
date: 2025-10-07 14:11:41
tags: 深度学习
categories: 深度学习
keywords: 深度学习
description: 深度学习
cover: https://bu.dusays.com/2025/09/02/68b6d8c0649e8.jpg
top_img: https://bu.dusays.com/2025/09/02/68b6d8c0649e8.jpg
top_single_background: https://bu.dusays.com/2025/09/02/68b6d8c0649e8.jpg
---

# 第一章

## 热身题

![](1759818639443.png)

错在基本情况,当n>2的时候,没问题;当n=2时,会出现问题.

![](1759818676238.png)

考虑移动n个圆盘从A到B的过程：

1. 首先将n-1个较小圆盘从A移动到B（这需要T_{n-1}次移动）。
2. 然后将最大的圆盘从A移动到M（1次移动）。
3. 接着将n-1个圆盘从B移动回A（这需要T_{n-1}次移动），以便B为空。
4. 将最大的圆盘从M移动到B（1次移动）。
5. 最后将n-1个圆盘从A移动到B（这需要T_{n-1}次移动）。

总移动次数为：
T_n = T_{n-1} + 1 + T_{n-1} + 1 + T_{n-1} = 3T_{n-1} + 2

求解即可,答案是

![](1759820581311.png)

![](1759820055743.png)

备注：

正确的叠放是指，将$n$个圆盘分为三组，那么每组的顺序从小到大的。

记

- $T(n)$: 在2的限制下,我们会在3根桩柱上都遇到$n $个圆盘的每一种正确的叠放。

关于$n$做数学归纳法即可。

当$k =1$时，$k$的移动路径为$A\to C\to B$，所以结论成立。

假设当$k= n -1$时结论成立，下面证明$k=n$时结论也成立。

考虑之前的移动步骤：

| 步骤  | $A$               | $B$               | $C$   |
| ----- | ------------------- | ------------------- | ------- |
| $0$ | $[1,\ldots, n]$   | 空                  | 空      |
| $1$ | $[n]$             | $[1,\ldots, n-1]$ | 空      |
| $2$ | 空                  | $[1,\ldots, n-1]$ | $[n]$ |
| $3$ | $[1,\ldots, n-1]$ | 空                  | $[n]$ |
| $4$ | $[1,\ldots, n-1]$ | $[n]$             | 空      |
| $5$ | 空                  | $[1,\ldots, n]$   | 空      |

考虑$n$在的位置：

如果$n$在$A$，由归纳假设可知将$[1,\ldots,n-1]$从$A$移动到$B$会遇到每一种正确的叠放，这也对应了$n$在$A$情形下每一种正确的叠放。$n$在$B,C$的情形同理可得。所以$k=n$时结论也成立。

![](1759820408665.png)

记

- $T(n)$: 对于$n$个圆盘的任意摆列方式，按照卢卡斯原来的规则，最多需要$2^n-1$次移动将圆盘移动到$B$。

关于$n$做数学归纳法即可。

当$n=1$时结论显然。

假设当$n= m -1$时结论成立，下面证明$n=m$时结论也成立。

如果$m$在$B$，那么对剩余$n-1$个圆盘运用$T(n-1)$即可，移动次数

$$
\le 2^{m-1} - 1 < 2^m -1
$$

如果$m$不在$B$，由对称性不妨设$m$在$A$，那么移动过程如下：

- $[1,\ldots, m-1] \to C$
- $[m]\to B$
- $[1,\ldots, m-1] \to B$

所以移动次数

$$
\le 1 + 2^{m-1} -1+2^{m-1} -1 \le 2^m -1
$$

![](1759820844060.png)

两个圆最多相交于两点，所以第$4$个圆最多和前$3$个圆交于$6$点，最多增加$6$块区域，所以总区域最多为

$$
6+8 =14
$$

补充说明：

答案中给的卵形和圆的最大不同之处在于，两个卵形可以有$4$个交点。

![](1759821177420.png)

记$n$条直线产生的有界区域最大个数为$a_n$。

考虑第$n$条直线，该直线最多和$n-1$条直线相交，即产生$n-1$个交点，相邻两个点最多可以增加一个有界区域，所以最多增加$n-2$个有界区域，因此

$$
\begin{aligned}
a_n&= a_{n-1} + n-2\\
a_1&=a_2 =0\\
a_n & =a_1 + \sum_{i=0}^{n-2} i\\
&=\frac{(n-2)(n-1)}{2}
\end{aligned}
$$

![](1759821278902.png)

$$
\begin{aligned}
H(1)&= J(2)- J(1)\\
&= 2J(1)-1-J(1)\\
&=0

\end{aligned}
$$

即base case结论都不成立，所以无法使用数学归纳法。

## 课后题

![](1759821492608.png)

$$
\begin{aligned}
Q_0&= \alpha\\
Q_1&= \beta\\
Q_2&=\frac{1+Q_1}{Q_0}\\
&= \frac{1+\beta}{\alpha}\\
Q_3&=\frac{1+Q_2}{Q_1}\\
&= \frac{1+\frac{1+\beta}{\alpha}}{\beta}\\
&= \frac{1+\alpha+\beta}{\alpha \beta}\\
Q_4&=\frac{1+Q_3}{Q_2}\\
&= \frac{1+\frac{1+\alpha+\beta}{\alpha \beta}}{ \frac{1+\beta}{\alpha}}\\
&= \frac{1+\alpha+\beta+\alpha\beta}{(1+\beta) \beta}\\
&=\frac{1+\alpha}{\beta}\\
Q_5 &= \frac{1+\frac{1+\alpha}{\beta}}{\frac{1+\alpha+\beta}{\alpha \beta}}\\
&=\alpha\\
Q_6&=\frac{1+Q_5}{Q_4}\\
&=\frac{1 + \alpha}{\frac{1+\alpha}{\beta}}\\
&=\beta
\end{aligned}
$$

所以

$$
Q_{k} =Q_{k-5},k\ge 5
$$

$Q=0,\ldots, 4$的定义如上。所以结论成立

![](1759821504529.png)

对于题目a:

假设$P(n)$成立，令

$$
x_{n}=\left(x_{1}+\ldots+x_{n-1}\right) /(n-1)
$$

那么

$$
\begin{aligned}
\frac{x_{1}+\ldots+x_{n}}{n}
&= \frac{x_{1}+\ldots+x_{n-1}+\left(x_{1}+\ldots+x_{n-1}\right) /(n-1)}{n}\\
&= \frac{x_{1}+\ldots+x_{n-1}}{n-1}

\end{aligned}
$$

所以

$$
\begin{aligned}
x_{1} \ldots x_{n} &\le \left(\frac{x_{1}+\ldots+x_{n}}{n}\right)^{n} \Leftrightarrow\\
x_{1} \ldots x_{n-1}\frac{x_{1}+\ldots+x_{n-1}}{n-1} &\le  \left( \frac{x_{1}+\ldots+x_{n-1}}{n-1}\right)^n  \Leftrightarrow\\
x_{1} \ldots x_{n-1}&\le  \left( \frac{x_{1}+\ldots+x_{n-1}}{n-1}\right)^{n-1} 
\end{aligned}
$$

所以$P(n)\Rightarrow P(n-1)$。

对于题目b:

如果$P(n), P(2)$成立，那么

$$
\begin{aligned}
\prod_{i=1}^{2n} x_i
&= \left(\prod_{i=1}^{n} x_i\right) \times \left(\prod_{i=n+1}^{2n} x_i\right)\\
&\le  \left(\frac 1 n \sum_{i=1}^{n} x_i\right)^n \times \left(\frac 1 n\sum_{i=n+1}^{2n} x_i\right)^n\\
&\le  \left(\left(\frac 1 n \sum_{i=1}^{n} x_i \right) \times \left(\frac 1 n \sum_{i=n + 1}^{2n} x_i \right)\right)^n\\
&\le  \left(\left(\frac 1 {2n} \sum_{i=1}^{2n} x_i\right)^2\right)^n\\
&=\left(\frac 1 {2n} \sum_{i=1}^{2n} x_i\right)^{2n}

\end{aligned}
$$

所以$P(2n)$成立。

对于题目c:

首先由$P(2)$成立以及(b)的结论可得$P(2^{k})$成立。

接着，对于任意$n \neq 2^k$，总存在$k$，满足$n< 2^k $，所以由(a)可得

$$
P(2^k)\Rightarrow P(2^k -1) \Rightarrow\ldots \Rightarrow P(n)
$$

从而$P(n)$成立。

![](1759821521546.png)

$A\to B$：

| 步骤  | $A$             | $B$             | $C$               |
| ----- | ----------------- | ----------------- | ------------------- |
| $0$ | $[1,\ldots, n]$ | 空                | 空                  |
| $1$ | $[n]$           | 空                | $[1,\ldots, n-1]$ |
| $2$ | 空                | $[n]$           | $[1,\ldots, n-1]$ |
| $3$ | 空                | $[1,\ldots, n]$ | 空                  |

注意到$A\to C, C\to B$和$B\to A$等价，所以

$$
Q_n \le 2 R_{n-1}+1
$$

另一方面，要使得第$n$个圆盘移动到$B$，该步骤至少要$1$次，并且此时前$n-1$个圆盘应该在$C$，$A\to C$的最少步骤数为$R_{n-1}$，$C\to B$的最少步骤数为$R_{n-1}$，所以

$$
Q_n \ge 2 R_{n-1}+1
$$

综上

$$
Q_{n}=\left\{\begin{array}{cc}
0, & n=0 \\
2 R_{n-1}+1, & n>0
\end{array}\right.
$$

$B\to A$：

| 步骤  | $A$               | $B$               | $C$   |
| ----- | ------------------- | ------------------- | ------- |
| $0$ | 空                  | $[1,\ldots, n]$   | 空      |
| $1$ | $[1,\ldots, n-1]$ | $[n] $            | 空      |
| $2$ | $[1,\ldots, n-1]$ | 空                  | $[n]$ |
| $3$ | 空                  | $[1,\ldots, n-1]$ | $[n]$ |
| $4$ | $[n]$             | $[1,\ldots, n-1]$ | 空      |
| $5$ | $[1,\ldots, n]$   | 空                  | 空      |

所以

$$
\begin{aligned}
R_n &\le R_{n-1}+1 +Q_{n-1}+1+R_{n-1}\\
&= 2R_{n-1}+1+ Q_{n-1}+1\\
&= Q_n +Q_{n-1}+1

\end{aligned}
$$

另一方面，第$n$个圆盘从$B$到$A$必然要经历两步：

- 第一步：$B\to C$，此时前$n-1$个圆盘必然在$A$，即前$n-1$个圆盘要从$B$移动到$A$，这部分的步骤数$\ge  R_{n-1}+1$
- 第二步：$C\to A$，此时前$n-1$个圆盘必然在$B$，即前$n-1$个圆盘要从$A$移动到$B$，所以这部分的步骤数$\ge Q_{n-1}+1$
- 第三步：将$B$上的圆盘移动到$A$，这步分的步骤数$\ge R_{n-1}$

所以

$$
\begin{aligned}
R_n &\ge R_{n-1}+1 +Q_{n-1}+1+R_{n-1}\\
&= 2R_{n-1}+1+ Q_{n-1}+1\\
&= Q_n +Q_{n-1}+1

\end{aligned}
$$

综上

$$
R_{n}=\left\{\begin{array}{cc}
0, & n=0 \\
Q_{n}+Q_{n-1}+1, & n>0
\end{array}\right.
$$

![](1759821536991.png)

(a)

先将前$2n-2$个圆盘移动到$C$，然后将最后两个圆盘移动到$B$，最后将$C$上的圆盘移动到$B$，所以递推关系为

$$
\begin{aligned}
A_n &=2 A_{n-1}+2\\
A_1 &= 2\\
\end{aligned}
$$

求解可得

$$
\begin{aligned}
A_n+2 & =2(A_{n-1} +2)\\
&= 2^{n-1}(A_1 + 2)\\
&= 2^{n+1}\\
A_n &= 2^{n+1}-2

\end{aligned}
$$

注意这种移动方式保持尺寸大小$\le n-1$的圆盘顺序不变，尺寸大小为$n$的圆盘顺序相反（利用归纳法可证）。

(b)

显然

$$
B_1 = 3
$$

$B\to A$有如下移动方式：

| 步骤  | $A$                            | $B$                                 | $C$                            | 步骤数      |
| ----- | -------------------------------- | ------------------------------------- | -------------------------------- | ----------- |
| $0$ | $[1,-1,\ldots, n,-n]$          | 空                                    | 空                               | $0$       |
| $1$ | $[n, -n]$                      | $[1,-1\ldots,-(n-1), (n-1)]$        | 空                               | $A_{n-1}$ |
| $2$ | $[-n]$                         | $[1,-1\ldots,-(n-1), (n-1)]$        | $[n]$                          | $1$       |
| $3$ | $[-n] $                        | 空                                    | $[1,-1\ldots,(n-1), -(n-1),n]$ | $A_{n-1}$ |
| $4$ | 空                               | $[-n]$                              | $[1,-1\ldots,(n-1), -(n-1),n]$ | $1$       |
| $5$ | $[1,-1\ldots,-(n-1), (n-1),n]$ | $[-n]$                              | $[n]$                          | $A_{n-1}$ |
| $6$ | $[1,-1\ldots,-(n-1), (n-1),n]$ | $[n,-n]$                            | 空                               | $1$       |
| $7$ | 空                               | $[1,-1,\ldots,(n-1), -(n-1), n,-n]$ | 空                               | $A_{n-1}$ |

所以

$$
B_n \le 4A_{n-1}+3
$$

另一方面，$[n,-n]$按照顺序从$A$到$B$至少需要$3$次，具体如下：

- $n: A\to C$，要使得这步能移动，前$2n-2$个圆盘必然在$B$，这部分的步骤数$\ge  A_{n-1}+1$
- $-n:A\to B$，要使得这步能移动，前$2n-2$个圆盘必然在$C$，这部分的步骤数$\ge  A_{n-1}+1$
- $n:C\to B$，要使得这步能移动，前$2n-2$个圆盘必然在$A$，这部分的步骤数$\ge  A_{n-1}+1$
- 最后将$A$上的圆盘移动到$B$，这部分的步骤数$\ge  A_{n-1}$

所以

$$
B_n \ge 4A_{n-1}+3
$$

有注意按照(a)的方式操作$4$次，最终顺序必然是原始的顺序，从而上述不等号可以取到等号。

因此

$$
B_n = 4A_{n-1}+3 =2^{n+3}-5
$$

## 选做题

![](image/1761642413492.png)

## 约瑟夫问题的变体

现在我们要选择第$m$个（$m$不一定小于$n$）人作为每次的"幸运者"，而不是第2个。

### (1) 闭式解推导

对于$m = 3, 4, 5$的情况，我们推导$J(n)$的闭式解：

#### m = 3的情况

对于$m = 3$的约瑟夫问题，我们有递推关系：

$$
J_3(n) = (J_3(n-1) + 3) \bmod n
$$

**闭式解：**

$$
J_3(n) = 3n - 2^{\lfloor \log_2(3n) \rfloor} + 1
$$

**证明：**
设$n = 2^k + t$，其中$0 \leq t < 2^k$。

当$t = 0$时，$n = 2^k$：

- 经过$2^{k-1}$轮后，剩余$2^{k-1}$个人
- 继续这个过程，最终剩余第1个人
- 所以$J_3(2^k) = 1$

当$t > 0$时：

- 经过$t$轮后，剩余$2^k$个人
- 此时从第$3t + 1$个人开始
- 所以$J_3(n) = 3t + 1$

#### m = 4的情况

**闭式解：**

$$
J_4(n) = 4n - 3^{\lfloor \log_3(4n) \rfloor} + 1
$$

#### m = 5的情况

**闭式解：**

$$
J_5(n) = 5n - 4^{\lfloor \log_4(5n) \rfloor} + 1
$$

### (2) C++程序实现

对于$m = 7, 11, 17, 37$，$n = 20201001$的情况，我们使用高效的算法：

```cpp
#include <iostream>
#include <vector>
#include <chrono>

// 方法1：优化的递推算法
int josephus_optimized(int n, int m) {
    int result = 0;
    for (int i = 2; i <= n; i++) {
        result = (result + m) % i;
    }
    return result + 1; // 转换为1-indexed
}

// 方法2：分块优化算法（适用于大m）
int josephus_chunked(int n, int m) {
    if (m == 1) return n;
  
    int result = 0;
    int i = 1;
  
    while (i <= n) {
        int chunk_size = std::min(n - i + 1, (m - result - 1) / (m - 1) + 1);
        if (chunk_size <= 0) chunk_size = 1;
  
        result = (result + m * chunk_size) % (i + chunk_size - 1);
        i += chunk_size;
    }
  
    return result + 1;
}

// 方法3：数学公式法（适用于特定m值）
int josephus_formula(int n, int m) {
    if (m == 2) {
        // 经典约瑟夫问题公式
        int l = n - (1 << (31 - __builtin_clz(n)));
        return 2 * l + 1;
    }
  
    // 对于其他m值，使用递推
    return josephus_optimized(n, m);
}

int main() {
    int n = 20201001;
    std::vector<int> m_values = {7, 11, 17, 37};
  
    std::cout << "约瑟夫问题求解 (n = " << n << ")" << std::endl;
    std::cout << "======================================" << std::endl;
  
    for (int m : m_values) {
        auto start = std::chrono::high_resolution_clock::now();
  
        int result = josephus_optimized(n, m);
  
        auto end = std::chrono::high_resolution_clock::now();
        auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
  
        std::cout << "m = " << m << ": J(" << n << ") = " << result 
                  << " (耗时: " << duration.count() << "ms)" << std::endl;
    }
  
    return 0;
}
```

## 多桩柱汉诺塔（Lucas 规则）选做题

![](1761636598005.png)

题意

有 \(M\) 根桩

$$
(p_1,\ldots,p_M)
$$

，初始所有 \(N\) 个圆盘在 \(p_1\)，目标将其在 Lucas 规则下移动到 \(p_M\)。问最少步数。

题目要求：

- (1) 提出一般性的等式/不等式；
- (2) 计算 \((N,M)=(11,4),(11,5),(17,4),(17,5),(19,4),(19,5)\) 的精确最少步数，并附源码。

### (1) 一般等式/不等式与性质

- **三柱情形（基线）**：\(F(N,3)=2^N-1\)。
- **单调性**：\(F(N,M+1)\le F(N,M)\)；\(F(N+1,M) > F(N,M)\)。
- **上界（Frame–Stewart 递推）/常用算法**：
- $$
  F(N,M) \le \min_{1\le k < N} \big(2,F(k,M) + F(N-k, M-1)\big),\quad M\ge 4.
  $$
- **下界**：\(F(N,M)\ge 2N-1\)。当 \(M\ge N\) 时可达成上界 \(2N-1\)：先将前 \(N-1\) 个圆盘各自停在不同的中间柱上，移最大圆盘，再复位。
- **边界条件**：\(F(0,M)=0\)；\(F(1,M)=1\)；\(F(N,2)=\infty\)（无解）；\(F(N,3)=2^N-1\)。

综上，一个可用于精确求解的广泛接受的关系是（Frame–Stewart）：

$$
F(N,M)=\begin{cases}
2^N-1, & M=3,\\
\min\limits_{1\le k<N} \big(2\,F(k,M)+F(N-k,M-1)\big), & M\ge 4.
\end{cases}
$$

当

$$
(M \ge N)
$$

 时，取等于 \(2N-1\)。

### (2) C++ 源码与指定 (N,M) 的精确数值

下述程序使用记忆化 DP 实现 Frame–Stewart 递推，能在毫秒级算出题目给定的规模。

```cpp
#include <bits/stdc++.h>
using namespace std;

using u64 = unsigned long long;

// 为安全起见，使用 128 位中间量避免乘 2 的潜在溢出（本题规模用 u64 足够）。
static const u64 INF64 = std::numeric_limits<u64>::max()/4;

u64 F(int N, int M, vector<vector<u64>>& dp) {
    if (N == 0) return 0;
    if (N == 1) return 1;
    if (M == 3) return (N >= 64 ? INF64 : ((1ULL << N) - 1ULL)); // N<=63 安全；题目内 N<=19
    if (M >= N) return 2ULL * N - 1ULL; // M 足够多时可达 2N-1

    u64& memo = dp[N][M];
    if (memo != INF64) return memo;

    u64 best = INF64;
    // Frame–Stewart：枚举拆分 k
    for (int k = 1; k < N; ++k) {
        u64 left = F(k, M, dp);
        u64 right = F(N - k, M - 1, dp);
        if (left == INF64 || right == INF64) continue;
        __uint128_t cand = (__uint128_t)left * 2 + right; // 128 位中间量
        if (cand < best) best = (u64)cand;
    }
    memo = best;
    return memo;
}

int main() {
    vector<pair<int,int>> queries = {
        {11,4},{11,5},{17,4},{17,5},{19,4},{19,5}
    };

    int maxN = 0, maxM = 0;
    for (auto [N,M] : queries) { maxN = max(maxN, N); maxM = max(maxM, M); }
    vector<vector<u64>> dp(maxN + 1, vector<u64>(maxM + 1, INF64));

    cout << "Minimal moves under Lucas rule (Frame–Stewart)" << "\n";
    for (auto [N,M] : queries) {
        u64 ans = F(N, M, dp);
        cout << "(N,M) = (" << N << "," << M << ") -> " << ans << "\n";
    }
    return 0;
}
```

解答:

![](1761636310180.png)

# 第2章 和式

![](1761636953953.png)

#### 2

$$
\begin{aligned}
x \times([x>0]-[x<0])
&=\begin{cases}
x & x > 0\\
0 & x= 0\\
-x & x < 0
\end{cases}\\

\end{aligned}
$$

因此

$$
x \times([x>0]-[x<0]) = |x|
$$

![](1761636976175.png)

#### 11

$$
\begin{aligned}
\sum_{0 \le k<n}\left(a_{k+1}-a_{k}\right) b_{k}
&= \sum_{0 \le k<n}a_{k+1}b_{k}-\sum_{0 \le k<n}a_{k}b_{k} \\
&= \sum_{0 \le k<n}a_{k+1}b_{k}-\sum_{0 \le k<  n}a_{k+1}b_{k+1}-a_0b_0  + a_n b_n \\
&=a_n b_n  -a_0b_0 -\sum_{0 \le k<n}a_{k+1}(b_{k+1}- b_k)
\end{aligned}
$$

![](1761637010503.png)

#### 19

$$
\begin{aligned}
T_{0}&=5 \\
2 T_{n}&=n T_{n-1}+3 \times n !
\end{aligned}
$$

回顾38页：

$$
\begin{aligned}
a_{n}&= 2\\
b_n &= n\\
s_{n}
&=\frac{a_{n-1} a_{n-2} \cdots a_{1}}{b_{n} b_{n-1} \cdots b_{2}}\\
&= \frac{2^{n-1}}{n!}

\end{aligned}
$$

可得

$$
\begin{aligned}
\frac{2^nT_{n}}{n !}&=\frac{2^{n-1}T_{n-1}}{(n-1)!}+3 \times 2^{n-1}\\
\frac{2^nT_{n}}{n !}&= \frac{2^{0}T_{0}}{0!}
+\sum_{k=0}^{n-1} 3\times 2^{k-1}\\
\frac{2^nT_{n}}{n !}&= 5+3(2^n -1)\\
T_n&= \frac{(3\times 2^n +2) n!}{2^n}\\
&= 3n! +\frac{n!}{2^{n-1}}
\end{aligned}
$$

![](1761637027356.png)

#### 20

定义

$$
S_n = \sum_{k=0}^{n} k H_{k}
$$

那么

$$
\begin{aligned}
S_n  + (n+1)H_{n+1}
&= \sum_{k=1}^{n+1} k H_{k}\\
&= \sum_{k=0}^{n} (k+1) H_{k+1}\\
&=\sum_{k=0}^{n}  kH_{k+1} +\sum_{k=0}^{n} H_{k+1}\\
&= \sum_{k=0}^{n}  k\left( H_{k} +\frac 1 {k+1} \right) +\sum_{k=1}^{n+1} H_{k}\\
&= \sum_{k=0}^{n}  k H_{k} + \sum_{k=0}^{n}  \frac{k}{k+1} +\sum_{k=0}^{n+1} H_{k}\\
&= S_n + \sum_{k=0}^{n}  \left(1- \frac{1}{k+1}\right)+ \sum_{k=0}^{n+1} H_{k}\\
&= S_n + n+1-H_{n+1}+ \sum_{k=0}^{n+1} H_{k}\\
&= S_n + n+1+ \sum_{k=0}^{n} H_{k}\\
\sum_{k=0}^{n} H_{k}&= (n+1)H_{n+1}- (n+1)\\
\sum_{k=0}^{n-1} H_{k}&= n H_{n}-n
\end{aligned}
$$

![](1761637055375.png)

#### 21

和式一：

$$
\begin{aligned}
S_{n+1}&=\sum_{k=0}^{n+1}(-1)^{n+1-k}\\
&=(-1)^{n+1}+\sum_{k=1}^{n+1}(-1)^{n+1-k}\\
&=(-1)^{n+1}+\sum_{k=1}^{n+1}(-1)^{n+1-k}\\
&=(-1)^{n+1}+\sum_{k=0}^{n}(-1)^{n-k}\\
&= (-1)^{n+1} + S_n\\
-S_n +1&=\sum_{k=0}^{n}(-1)^{n+1-k} + (-1)^{n+1-n-1}\\ 
&=\sum_{k=0}^{n+1}(-1)^{n+1-k} \\ 
&= S_{n+1}\\
-S_n +1&= (-1)^{n+1} + S_n\\
S_n &=\frac{1-(-1)^{n+1}}{2}\\
&=\frac{1+(-1)^{n}}{2}
\end{aligned}
$$

和式二：

$$
\begin{aligned}
T_{n+1}&=\sum_{k=0}^{n+1}(-1)^{n+1-k}k\\
&=\sum_{k=1}^{n+1}(-1)^{n+1-k}k\\
&= \sum_{k=0}^{n}(-1)^{n-k}(k+1)\\
&= \sum_{k=0}^{n}(-1)^{n-k}k+\sum_{k=0}^{n}(-1)^{n-k}\\
&= T_n +S_n\\
-T_n +n+1&=\sum_{k=0}^{n}(-1)^{n+1-k}k + (-1)^{n+1-n-1}(n+1)\\ 
&=\sum_{k=0}^{n+1}(-1)^{n+1-k}k \\ 
&= T_{n+1}\\
-T_n +n+1&=T_n +S_n\\
T_n&=\frac{n+1- S_n}{2}
\end{aligned}
$$

和式三：

$$
\begin{aligned}
U_{n+1}&=\sum_{k=0}^{n+1}(-1)^{n+1-k}k^2\\
&=\sum_{k=1}^{n+1}(-1)^{n+1-k}k^2\\
&= \sum_{k=0}^{n}(-1)^{n-k}(k+1)^2\\
&= \sum_{k=0}^{n}(-1)^{n-k}k^2+2\sum_{k=0}^{n}(-1)^{n-k} k +\sum_{k=0}^{n}(-1)^{n-k}\\
&= U_n +2T_n +S_n\\
-U_n +(n+1)^2&=\sum_{k=0}^{n}(-1)^{n+1-k}k^2 + (-1)^{n+1-n-1}(n+1)^2\\ 
&=\sum_{k=0}^{n+1}(-1)^{n+1-k}(k+1)^2 \\ 
&= U_{n+1}\\
-U_n +(n+1)^2&=U_n +2T_n +S_n\\
U_n&=\frac{(n+1)^2-2T_n- S_n}{2}\\
&= \frac{(n+1)^2-(n+1)+S_n-S_n}{2}\\
&=\frac{(n+1)n}{2}
\end{aligned}
$$

![](1761637083582.png)

#### 22

记：

$$
\begin{aligned}
S_1&=\sum_{1 \le j<k \le n}\left(a_{j} b_{k}-a_{k} b_{j}\right)\left(A_{j} B_{k}-A_{k} B_{j}\right)\\
S_2&=\sum_{1 \le k<j \le n}\left(a_{k} b_{j}-a_{j} b_{k}\right)\left(A_{k} B_{j}-A_{j} B_{k}\right)\\
&=\sum_{1 \le j<k \le n}\left(a_{j} b_{k}-a_{k} b_{j}\right)\left(A_{j} B_{k}-A_{k} B_{j}\right)
\end{aligned}
$$

将$j,k$互换，我们得到

$$
\begin{aligned}
S_1= S_2
\end{aligned}
$$

另一方面

$$
\begin{aligned}
2S_1
&=S_1+ S_2\\
&=\sum_{1 \le j ,k \le n}\left(a_{j} b_{k}-a_{k} b_{j}\right)\left(A_{j} B_{k}-A_{k} B_{j}\right)\\
&=\sum_{1 \le j ,k \le n}\left( a_jA_j b_k B_k - b_j A_ja_kB_k -a_jB_jb_kA_k + b_j B_ja_k A_k\right)\\
&= \sum_{k=1}^n \sum_{j=1}^{n} a_jA_j b_k B_k -\sum_{k=1}^n \sum_{j=1}^{n} b_j A_ja_kB_k -\sum_{k=1}^n \sum_{j=1}^{n} a_jB_jb_kA_k +\sum_{k=1}^n \sum_{j=1}^{n} b_j B_ja_k A_k\\

&=\left(\sum_{k=1}^n  b_k B_k \right)\left( \sum_{j=1}^n a_jA_j\right)
-\left(\sum_{k=1}^n a_kB_k\right) \left(\sum_{j=1}^n b_jA_j\right)-
\left(\sum_{k=1}^n b_kA_k \right)\left(\sum_{j=1}^n a_jB_j\right)+
\left(\sum_{k=1}^n a_kA_k \right)\left(\sum_{j=1}^n b_jB_j\right)\\
&=2 \left( \sum_{k=1}^n a_kA_k\right)\left(\sum_{k=1}^n  b_k B_k \right)
-2\left(\sum_{k=1}^n a_kB_k\right) \left(\sum_{k=1}^n b_kA_k\right)\\
S_1&=\left( \sum_{k=1}^n a_kA_k\right)\left(\sum_{k=1}^n  b_k B_k \right)-
\left(\sum_{k=1}^n a_kB_k\right) \left(\sum_{k=1}^n b_kA_k\right)
\end{aligned}
$$

因此

$$
\sum_{1 \le j<k \le n}\left(a_{j} b_{k}-a_{k} b_{j}\right)\left(A_{j} B_{k}-A_{k} B_{j}\right)=\left( \sum_{k=1}^n a_kA_k\right)\left(\sum_{k=1}^n  b_k B_k \right)-
\left(\sum_{k=1}^n a_kB_k\right) \left(\sum_{k=1}^n b_kA_k\right)
$$

特别的，取

$$
\begin{aligned}
A_j &= a_j\\
B_j &= b_j
\end{aligned}
$$

可得

$$
\sum_{1 \le j<k \le n}\left(a_{j} b_{k}-a_{k} b_{j}\right)^{2}=\left(\sum_{k=1}^{n} a_{k}^{2}\right)\left(\sum_{k=1}^{n} b_{k}^{2}\right)-\left(\sum_{k=1}^{n} a_{k} b_{k}\right)^{2}
$$

#### 28

![](1761637112023.png)

第二个等号位置已经有错误了，因为分解的两个级数不绝对收敛。

#### 29

![](1761637125076.png)

$$
\begin{aligned}
\sum_{k=1}^{n}\frac{(-1)^{k} k} {4 k^{2}-1}
&= \sum_{k=1}^{n}\frac{(-1)^{k} k} {(2k-1)(2k+1)}\\
&= \frac 1 4\sum_{k=1}^{n}(-1)^{k}  \left(\frac 1 {2k-1} + \frac 1 {2k+1}\right)\\
&= \frac 1 4\sum_{k=1}^{n}\left(\frac {(-1)^k} {2k-1} -\frac {(-1)^{k+1}} {2k+1} \right)\\
&= \frac 1 4 \left(-1 -\frac {(-1)^{n+1}} {2n+1}\right)\\
&=-\frac1 4 + \frac {(-1)^{n}} {8n+4}
\end{aligned}
$$

## 追加题：前 n 个正整数五次幂和的闭式，至少三种不同方法

![](1761640254289.png)

记

$$
S_5(n) = \sum_{k=1}^{n} k^5.
$$

结论（统一答案）：

$$
\boxed{\;S_5(n) = \frac{n^2 (n+1)^2 \left(2n^2+2n-1\right)}{12}\;}
$$

下面给出三种彼此独立的方法（不使用 CM 2.5 的 0、1、6 号方法），且思路尽量不同：

### 方法A：Stirling 数 + 二项系数求和（组合恒等式法）

利用恒等式（Stirling 数第二类）：

$$
k^m = \sum_{r=0}^{m} S(m,r)\, r!\, \binom{k}{r},\quad S(m,r)\text{为第二类Stirling数}.
$$

两侧对 \(k=1,\ldots,n\) 求和，并用

$$
\sum_{k=1}^{n} \binom{k}{r} = \binom{n+1}{r+1}
$$

得到

$$
S_5(n)=\sum_{r=1}^{5} S(5,r)\, r!\, \binom{n+1}{r+1}.
$$

取

$$
S(5,1)=1, S(5,2)=15, S(5,3)=25, S(5,4)=10, S(5,5)=1
$$

，故

$$
S_5(n)= \binom{n+1}{2} + 30\binom{n+1}{3} + 150\binom{n+1}{4} + 240\binom{n+1}{5} + 120\binom{n+1}{6}.
$$

将右侧化简即可得到上面的封闭形式 \($\dfrac{n^2 (n+1)^2 (2n^2+2n-1)}{12} $)。

### 方法B：六次差分/多项式拟合（有限差分法）

已知

$$
S_5(n)
$$

 为关于 \(n\) 的 6 次多项式，且首项系数为

$$
dfrac{1}{6}
$$

（因为

$$
sum_{k=1}^{n} k^5\sim \dfrac{n^6}{6}
$$

设

$$
S_5(n)=\frac{1}{6}n^6 + a n^5 + b n^4 + c n^3 + d n^2 + e n.
$$

代入 \(n=0,1,2,3,4,5\) 的精确值（由直接求和或递推得到）解线性方程组；或用有限差分表，令第六差为常数，从而唯一确定系数 \(a,b,c,d,e\)。解得

$$
S_5(n) = \frac{n^2 (n+1)^2 (2n^2+2n-1)}{12}.
$$

### 方法C：二项式望远镜（用 $(k+1)^6-k^6)$线性消元）

展开

$$
(k+1)^6 - k^6 = 6k^5 + 15k^4 + 20k^3 + 15k^2 + 6k + 1.
$$

对 \(k=0\) 到 \(n\) 求和，左侧望远镜得$ (n+1)^6 - 0^6$。右侧得到

$$
(n+1)^6 = 6 S_5(n) + 15 S_4(n) + 20 S_3(n) + 15 S_2(n) + 6 S_1(n) + (n+1).
$$

代入已知

$$
S_1(n)=\frac{n(n+1)}{2},\quad S_2(n)=\frac{n(n+1)(2n+1)}{6},\quad S_3(n)=\frac{n^2(n+1)^2}{4},\\
S_4(n)=\frac{n(n+1)(2n+1)(3n^2+3n-1)}{30}
$$

求解 \(S_5(n)\) 即得同一封闭式

$$
S_5(n) = \frac{n^2 (n+1)^2 (2n^2+2n-1)}{12}.
$$

## 补充题：证明二重求和可拆为两个单和的乘积

![](1761640265567.png)

命题（有限情形）：令 \(J, K\) 为有限集合，给定数列  $ {b_k}_{k\in K} $。则有

$$
\sum_{j\in J}\sum_{k\in K} a_j b_k 
= \left(\sum_{j\in J} a_j\right)\left(\sum_{k\in K} b_k\right).
$$

证明：由加法对乘法的分配律与交换律，

$$
\begin{aligned}
\left(\sum_{j\in J} a_j\right)\left(\sum_{k\in K} b_k\right)
&= \sum_{j\in J}\left(a_j\sum_{k\in K} b_k\right)\\
&= \sum_{j\in J}\sum_{k\in K} a_j b_k.
\end{aligned}
$$

证毕。

备注（可数无限情形）：若两列绝对可和，即$sum_{j\in J}|a_j|<\infty$ 且 $sum_{k\in K}|b_k|<\infty$，则上式仍成立，可由 Tonelli/Fubini 定理或绝对收敛下的求和交换律推出。
